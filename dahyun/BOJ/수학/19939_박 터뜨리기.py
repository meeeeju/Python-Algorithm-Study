# 블로그 참고
'''
k개의 바구니가 있을 때 위의 조건을 만족하기 위해서 필요한 공의 개수는 최소 1+2+3+4+ ... + k 개

공의 개수가 k*(k+1)/2보다 작다면 모든 바구니에 다른 개수의 공을 넣는 것이 불가능하다.(조건을 만족하는 최소 공의 개수이기 때문)
 
공의 개수가 k*(k+1)/2보다 클 때
 
공의 개수 - k*(k+1)/2의 값이 몇이냐가 정답을 결정짓게 된다. 이 값을 a라고 하면
a가 k(바구니 개수)의 배수라면 모든 바구니에 동일한 개수만큼 공을 더 넣어주면 되기에
가장 적은 공의 개수와 가장 많은 공의 개수 사이의 차는 변하지 않는다 (k-1)
 
만일 a가 k의 배수가 아니라면 a%k 는 1부터 k-1 사이의 값이 될 것이다. 
이 경우 가장 개수가 많은 바구니부터 적은 바구니 순으로 공을 하나씩 추가해주면 가장 개수가 적은 바구니에는 공이 추가되지 않는다.
(모든 공의 개수를 다르게 하기 위함)
따라서 가장 적은 공의 개수와 가장 많은 공의 개수 사이의 차는 k가 된다.
 
'''
n, k = map(int, input().split())

check = k*(k+1) //2

if n < check:  # 공의 개수가 k*(k+1)/2보다 작다면 모든 바구니에 다른 개수의 공을 넣는 것이 불가능
    print(-1)
elif (n - check) % k == 0:
    print(k-1)
else:
    print(k)
